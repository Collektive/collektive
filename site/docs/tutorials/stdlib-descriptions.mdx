---
title: Standard Library Functions
---

import { useState } from "react";
import ReactMarkdown from "react-markdown";
import rehypeRaw from 'rehype-raw';

export default function OperatorList() {
const operators = [
{name: `distanceTo(
>source: Boolean,
>bottom: Distance,
>top: Distance,
>crossinline accumulateDistance: (Distance, Distance) -> Distance,
>crossinline metric: () -> Field<ID, Distance>

): 

Distance = gradientCast(
>source = source,
>local = if (source) bottom else top,
>bottom = bottom,
>top = top,
>accumulateData = { neighborToSource, hereToNeighbor, _ -> accumulateDistance(neighborToSource, hereToNeighbor)},
>accumulateDistance,
>metric

)
`, description: `\## Description 

\`distanceTo(source: Boolean,
    bottom: Distance,
    top: Distance,
    crossinline accumulateDistance: (Distance, Distance) -> Distance,
    crossinline metric: () -> Field<ID, Distance>)\` is a spreading function: compute the \`Distance\` from the closest \`source\`, starting from \`bottom\` and up to \`top\`.

The \`Distance\` between neighboring devices is computed using the \`metric\` function, the distance summation is governed by the \`accumulateDistance\` function.
`},

{name: `hopDistanceTo(source: Boolean): 

Int = distanceTo(source, 0, Int.MAX_VALUE, Int::plus) { neighboring(1) } 
`, description: `\## Description 

\`hopDistanceTo(source: Boolean)\` is a spreading function: computes the hop distance from the closest \`source\`.
`},
{name: `distanceTo(source: Boolean, crossinline metric: () -> Field<ID, Double> = { neighboring(1.0) }):

Double = distanceTo(source, 0.0, Double.POSITIVE_INFINITY, Double::plus, metric)
`, description: `\## Description 

\`distanceTo(source: Boolean, crossinline metric: () -> Field<ID, Double> = { neighboring(1.0) })\` is a spreading function: compute the distance from the closest \`source\`, using \`Double\`s.

The distance between neighboring devices is computed using the \`metric\` function, and defaults to the hop distance.
`},
{name: `gradientCast(

>source: Boolean,

>local: Value,

>bottom: Distance,

>top: Distance,

>crossinline accumulateData: (fromSource: Distance, toNeighbor: Distance, data: Value) -> Value = { _, _, data -> data },

>crossinline accumulateDistance: (fromSource: Distance, toNeighbor: Distance) -> Distance,

>crossinline metric: () -> Field<ID, Distance>

): 

Value {

>val topValue = top to local

>return share(topValue) { neighborData ->

>>val paths = neighborData.alignedMap(metric().coerceIn(bottom, top)) { (fromSource, data), toNeighbor ->

>>>val totalDistance = accumulateDistance(fromSource, toNeighbor).coerceIn(bottom, top)

>>>check(totalDistance >= fromSource && totalDistance >= toNeighbor) {"The provided distance accumulation function violates the triangle inequality: " + "accumulating $fromSource and $toNeighbor produced $totalDistance"}

>>>val newData = accumulateData(fromSource, toNeighbor, data)

>>>totalDistance to newData

>>>}

>>when {

>>>source -> bottom to local

>>>else -> paths.minBy(base = topValue) { it.first } // sort by distance from the nearest source

>>}

>}.second // return the data

}
`, description: `\## Description 

\`gradientCast(source: Boolean,
    local: Value,
    bottom: Distance,
    top: Distance,
    crossinline accumulateData: (fromSource: Distance, toNeighbor: Distance, data: Value) -> Value = { _, _, data -> data },
    crossinline accumulateDistance: (fromSource: Distance, toNeighbor: Distance) -> Distance,
    crossinline metric: () -> Field<ID, Distance>)\` is a spreading function:  propagate \`local\` values across a spanning tree starting from the closest \`source\`.

If there are no sources and no neighbors, default to \`local\` value.

The \`metric\` function is used to compute the distance between devices in form of a field of \`Distance\`s.

\`Distance\`s must be in the \`bottom\`, \`top\` range, \`accumulateDistance\` is used to sum distances.

\`accumulateData\` is used to modify data from neighbors on the fly, and defaults to the identity function.

This function features *incremental repair*, and it is subject to the *rising value problem*, see [Fast self-healing gradients](https://doi.org/10.1145/1363686.1364163).
`},
{name: `multiGradientCast(

>sources: Iterable<ID>,

>local: Value,

>bottom: Distance,

>top: Distance,

>crossinline accumulateData: (fromSource: Distance, toNeighbor: Distance, data: Value) -> Value = { _, _, data -> data },

>crossinline accumulateDistance: (Distance, Distance) -> Distance,

>crossinline metric: () -> Field<ID, Distance>

): Map<ID, Value> = sources.associateWith { source ->

>alignedOn(source) {

>>gradientCast(source == localId, local, bottom, top, accumulateData, accumulateDistance, metric)

>}

}
`, description: `\## Description 

\`multiGradientCast(sources: Iterable<ID>,
    local: Value,
    bottom: Distance,
    top: Distance,
    crossinline accumulateData: (fromSource: Distance, toNeighbor: Distance, data: Value) -> Value =
        { _, _, data -> data },
    crossinline accumulateDistance: (Distance, Distance) -> Distance,
    crossinline metric: () -> Field<ID, Distance>)\` is a spreading function: provided a list of \`sources\`, propagates information from each, collecting it in a map.

If there are no sources and no neighbors, default to \`local\` value.

The \`metric\` function is used to compute the distance between devices in form of a field of \`Float\`s.

\`accumulateData\` is used to modify data from neighbors on the fly, and defaults to the identity function.
`},
{name: `gradientCast(

>source: Boolean,

>local: Value,


>crossinline accumulateData: (fromSource: Int, toNeighbor: Int, data: Value) -> Value = { _, _, data -> data },

>crossinline metric: () -> Field<ID, Int> = { neighboring(1) }

): 

Value = gradientCast(source, local, Int.MIN_VALUE, Int.MAX_VALUE, accumulateData, Int::plus, metric)
`, description: `\## Description 

\`gradientCast(source: Boolean,
    local: Value,
    crossinline accumulateData: (fromSource: Int, toNeighbor: Int, data: Value) -> Value = { _, _, data -> data },
    crossinline metric: () -> Field<ID, Int> = { neighboring(1) })\` is a spreading function: propagate \`local\` values across a spanning tree starting from the closest \`source\`.

If there are no sources and no neighbors, default to \`local\` value.

The \`metric\` function is used to compute the distance between devices in form of a field of \`Int\`s.

\`accumulateData\` is used to modify data from neighbors on the fly, and defaults to the identity function.
`},
{name: `gradientCast(

>source: Boolean,

>local: Value,

>crossinline accumulateData: (fromSource: Double, toNeighbor: Double, data: Value) -> Value = { _, _, data -> data },

>crossinline metric: () -> Field<ID, Double> = { neighboring(1.0) }

): 

Value = gradientCast(source, local, 0.0, Double.POSITIVE_INFINITY, accumulateData, Double::plus, metric)
`, description: `\## Description 

\`gradientCast(source: Boolean,
    local: Value,
    crossinline accumulateData: (fromSource: Double, toNeighbor: Double, data: Value) -> Value = { _, _, data -> data },
    crossinline metric: () -> Field<ID, Double> = { neighboring(1.0) })\` is a spreading function: propagate \`local\` values across a spanning tree starting from the closest \`source\`.

If there are no sources and no neighbors, default to \`local\` value.

The \`metric\` function is used to compute the distance between devices in form of a field of \`Double\`s.

\`accumulateData\` is used to modify data from neighbors on the fly, and defaults to the identity function.
`},
{name: `multiGradientCast(

>sources: Iterable<ID>,

>local: Value,

>crossinline accumulateData: (fromSource: Double, toNeighbor: Double, data: Value) -> Value = { _, _, data -> data },

>crossinline metric: () -> Field<ID, Double> = { neighboring(1.0) },

): 

Map<ID, Value> = sources.associateWith { source ->

>alignedOn(source) {

>>gradientCast(source == localId, local, 0.0, Double.POSITIVE_INFINITY, accumulateData, Double::plus, metric)

>}

}

`, description: `\## Description 

\`multiGradientCast(
    sources: Iterable<ID>,
    local: Value,
    crossinline accumulateData: (fromSource: Double, toNeighbor: Double, data: Value) -> Value = { _, _, data -> data },
    crossinline metric: () -> Field<ID, Double> = { neighboring(1.0) })\` is a spreading function: provided a list of \`sources\`, propagates information from each, collecting it in a map.

If there are no sources and no neighbors, default to \`local\` value.

The \`metric\` function is used to compute the distance between devices in form of a field of \`Float\`s.

\`accumulateData\` is used to modify data from neighbors on the fly, and defaults to the identity function.
`},
{name: `multiGradientCast(

>sources: Iterable<ID>,

>local: Value,

>crossinline accumulateData: (fromSource: Int, toNeighbor: Int, data: Value) -> Value = { _, _, data -> data },

>crossinline metric: () -> Field<ID, Int> = { neighboring(1) },

): 

Map<ID, Value> = sources.associateWith { source ->

>alignedOn(source) {

>>gradientCast(source == localId, local, Int.MIN_VALUE, Int.MAX_VALUE, accumulateData, Int::plus, metric)

>}

}
`, description: `\## Description 

\`multiGradientCast(sources: Iterable<ID>,
    local: Value,
    crossinline accumulateData: (fromSource: Int, toNeighbor: Int, data: Value) -> Value = { _, _, data -> data },
    crossinline metric: () -> Field<ID, Int> = { neighboring(1) })\` is a spreading function: provided a list of \`sources\`, propagates information from each, collecting it in a map.

If there are no sources and no neighbors, default to \`local\` value.

The \`metric\` function is used to compute the distance between devices in form of a field of \`Float\`s.

\`accumulateData\` is used to modify data from neighbors on the fly, and defaults to the identity function.
`},
{name: `gossipMax(local: Value, comparator: Comparator<Value>): 

Value {

>val localGossip = GossipValue<ID, Value>(best = local, local = local)

>return share(localGossip) { gossip -> 

>>val neighbors = gossip.neighbors.toSet()

>>val result = gossip.foldWithId(localGossip) { current, id, next ->

>>>val valid = next

>>>>.path

>>>>.asReversed()

>>>>.asSequence()

>>>>.drop(1)

>>>>.none { it == localId || it in neighbors }

>>>val actualNext = if (valid) next else next.base(id)

>>>val candidateValue = comparator.compare(current.best, actualNext.best)

>>>when {

>>>>candidateValue > 0 -> current

>>>>candidateValue == 0 -> listOf(current, next).minBy { it.path.size }

>>>>else -> actualNext

>>>}

>>}

>GossipValue(result.best, local, result.path + localId)

>}.best

}
`, description: `\## Description 

\`gossipMax(local: Value, comparator: Comparator<Value>)\` is a gossip function: self-stabilizing gossip-max.

Spreads across all (aligned) devices the current maximum \`Value\` of \`local\`, as computed by \`comparator\`.
`},
{name: `gossipMax(local: Value): 

Value = gossipMax(local) { first, second -> first.compareTo(second) }
`, description: `\## Description 

\`gossipMax(local: Value)\` is a gossip function: self-stabilizing \`gossipMax\` with a default comparator.

Spreads across all (aligned) devices the current maximum \`Value\` of \`local\`, as computed by first value compared to the second.
`},
{name: `gossipMin(local: Value, comparator: Comparator<Value>):

Value = gossipMax(local, comparator.reversed()) 
`, description: `\## Description 

\`gossipMin(local: Value, comparator: Comparator<Value>)\` is a gossip function: self-stabilizing gossip-min.

Spreads across all (aligned) devices the current minimum \`Value\` of \`local\`, as computed by \`comparator\`.
`},
{name: `gossipMin(local: Value):

Value = gossipMin(local) { first, second -> first.compareTo(second) }
`, description: `\## Description 

\`gossipMin(local: Value)\` is a gossip function: self-stabilizing \`gossipMin\` with a default comparator.

Spreads across all (aligned) devices the current minimum \`Value\` of \`local\`, as computed by first value compared to the second, and then reversed.
`},
{name: `isHappeningAnywhere(condition: () -> Boolean): 

Boolean = gossipMax(condition()) { first, second -> first.compareTo(second) }
`, description: `\## Description 

\`isHappeningAnywhere(condition: () -> Boolean)\` is a gossip function: returns true if the condition is holding anywhere in the network, false otherwise.

`},
{name: `nonStabilizingGossip(value: Value, noinline aggregation: (Value, Value) -> Value): 

Value = share(value) { it.fold(value, aggregation) }
`, description: `\## Description 

\`nonStabilizingGossip(value: Value, noinline aggregation: (Value, Value) -> Value)\` is a gossip function: a **non-self-stabilizing** gossip function for repeated propagation of a \`value\` and \`aggregation\` of state estimates between neighboring devices.

`},
{name: `everHappened(condition: () -> Boolean): 

Boolean = nonStabilizingGossip(condition()) { a, b -> a || b }
`, description: `\## Description 

\`everHappened(condition: () -> Boolean)\` is a gossip function: A **non-self-stabilizing** function returning \`true\` if at any point in time a certain \`condition\` happened.

*Note:* due to its non-self-stabilizing nature, if the \`condition\` does not hold anymore, this function will keep returning \`true\`.

To check whether a condition is still holding, use \`isHappeningAnywhere\`
`},
{name: `coerceIn(min: T, max: T): 

T = minOf(max, maxOf(this, min))
`, description: `\## Description 

\`coerceIn(min: T, max: T)\` is a comparable function: coerce this value to be in the range between \`min\` and \`max\`.
`},
{name: `coerceIn(range: ClosedRange<T>): 

T = minOf(range.endInclusive, maxOf(this, range.start))
`, description: `\## Description 

\`coerceIn(range: ClosedRange<T>)\` is a comparable function: coerce this value in a \`range\`.
`},
{name: `coerceIn(min: T, max: T): 

Field<ID, T> = map { it.coerceIn(min, max) }
`, description: `\## Description 

\`coerceIn(min: T, max: T)\` is a comparable function: coerce all field values to be in the range between \`min\` and \`max\`.
`},
{name: `coerceIn(range: ClosedRange<T>): 

Field<ID, T> = map { it.coerceIn(range) }
`, description: `\## Description 

\`coerceIn(range: ClosedRange<T>)\` is a comparable function: coerces all field values in a \`range\`.
`}
]

const [search, setSearch] = useState("");

// Filter operators based on search
const filteredOperators = operators.filter(op =>
    op.name.toLowerCase().includes(search.toLowerCase())
);

const highlightMatch = (text, searchTerm) => {
    if (!searchTerm) return text; 
    const escapedSearchTerm = searchTerm.replace(/[-/\\^$*+?.()|[\]{}]/g, '\\$&');

    const regex = new RegExp(`(${escapedSearchTerm})`, 'gi');
    return text.replace(regex, (match) => {
        return `<mark class="bg-yellow-300">${match}</mark>`; 
    });
};

return (
    <div className="max-w-md mx-auto p-6 bg-white shadow-lg rounded-2xl">
        <h2 className="text-xl font-semibold text-purple-600 mb-4">
        The standard library functions present in the Collektive library are illustrated below
        </h2>
        
        {/* Search bar */}
        <input
        type="text"
        placeholder="🔍 Search for a function..."
        className="w-full h-12 p-3 text-lg border rounded-lg focus:outline-none focus:ring-2 focus:ring-purple-400"
        value={search}
        onChange={(e) => setSearch(e.target.value)}
        />

        {/* Operator list with description in Markdown */}
        <ul className="mt-4 space-y-3">
        {filteredOperators.length > 0 ? (
            filteredOperators.map((op) => (
            <li key={op.name} className="p-3 bg-gray-100 rounded-lg shadow-sm text-lg">
                <ReactMarkdown 
                    className="font-bold text-purple-700"
                    children={highlightMatch(op.name, search)} 
                    rehypePlugins={[rehypeRaw]}
                />
                <details style={{ backgroundColor: 'transparent', border: '1px solid purple', borderRadius: '5px', padding: '5px' }}>
                    <summary>Click to view description</summary>
                    <ReactMarkdown className="text-gray-600 text-sm">
                            {op.description}
                    </ReactMarkdown>
                </details>
            </li>
            ))
        ) : (
            <li className="text-gray-500 text-lg">No operators found</li>
        )}
        </ul>
    </div>
);
}