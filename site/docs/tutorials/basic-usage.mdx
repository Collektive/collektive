---
title: Basic Usage
---

# Simple examples

## First example

A preliminary code example demonstrates how devices, through mutual communication, are able to identify the maximum ID among the neighboring nodes within their local network area (neighborhood):

```kotlin
/**
 * First example - Tutorial:
 * 1. Identify the maximum value among the neighboring nodes.
 * 2. Assign a distinct color to the nodes with the identified maximum values.
*/

fun Aggregate<Int>.maxID(environment: EnvironmentVariables) = maxNeighborID(environment)

fun Aggregate<Int>.maxNeighborID(environment: EnvironmentVariables): Int {
    // Step 1: Exchange the localId with neighbors and obtain a field of values
    val neighborValues = neighboring(local = localId)

    // Step 2: Find the maximum value among neighbors (including self)
    val maxValue = neighborValues.max(base = localId)

    // Step 3: Assign the result to a molecule (only if using Alchemist)
    environment["isMaxID"] = localId == maxValue
    environment["localID"] = localId
    environment["maxNeighborID"] = maxValue

    return maxValue
}

```
The library function `neighboring(local: Scalar)` is a **aggregate operator** and is used to observe the value of an expression [local] across neighboring nodes.

#### Example

```kotlin
val field = neighboring(0)
```

The returned field has as its local value the value passed as input (0 in this example).

The simulation environment used to demonstrate these examples is [Alchemist simulator](https://alchemistsimulator.github.io/). 

However, it is important to emphasize that the Collektive library is designed for broader applicability and is not limited to this specific tool.

The correct execution of this exercise does not depend on Alchemist Simulator or the environment used for molecule assignment. The latter serves solely a graphical purpose, enabling the visualization of results by assigning different colors based on the identified maximum values.

<details style={{ backgroundColor: 'transparent', border: '1px solid purple', borderRadius: '5px', padding: '5px' }}>
  <summary>Click to view images</summary>
  <div style={{ textAlign: 'center' }}>
    <img src="/img/basic-usage-first-example-1.png" style={{ maxWidth: '70%' }} />
  </div>
  In the initial configuration depicted in the first image, all nodes have the "isMaxID" flag initially set to true. A node for which "isMaxID == true" is represented in red.

  It is observed that the network has a low degree of connectivity, leading to the formation of multiple small subnetworks. 
  
  The resulting configuration after executing the code shown above is as follows:
  <div style={{ textAlign: 'center' }}>
    <img src="/img/basic-usage-first-example-2.png" style={{ maxWidth: '70%' }} />
  </div>

  The obtained result is briefly analyzed by considering one of these small subnetworks as an example. Specifically, we examine the nodes with ID 197, 277, and the intermediate node connecting them. 
  <div style={{ textAlign: 'center' }}>
    <img src="/img/basic-usage-first-example-3.png" style={{ maxWidth: '70%' }} />
  </div>

  In the figure, the ID of the intermediate node between nodes 197 and 277 is not displayed, but it can reasonably be assumed to be lower than those of the other two nodes. For this reason, both node 277 and node 197 have the flag "isMaxID == true." However, it is observed that node 197 does not recognize node 277 as the maximum. This occurs because there is no direct communication between them, and each node only transmits its own ID to its neighbors. This mechanism leads to a solution characterized by local maxima.
</details>

The example we have seen represents a straightforward instance of aggregated behavior.

## Second example

This second example represents a variation of the previous one. Building upon the local maximum computation introduced in the first example, the code presented here extends the process through a second layer of communication among nodes, enabling convergence toward the global maximum of the network. 

**Note**: the global maximum is visually represented in green, while the local maximum is consistently indicated in red.

```kotlin
/**
 * First example - Tutorial:
 * 1. Identify the maximum value among the neighboring nodes.
 * 2. Assign a distinct color to the nodes with the identified maximum values.
 * Second example - Tutorial:
 * 3. Identify the maximum value in the network.
 * 4. Assign a distinct color to the nodes with the identified maximum values.
*/

fun Aggregate<Int>.maxID(environment: EnvironmentVariables) = maxNetworkID(environment)

fun Aggregate<Int>.maxNeighborID(): Int {
    // Step 1: Exchange the localId with neighbors and obtain a field of values
    val neighborValues = neighboring(local = localId)

    // Step 2: Find the maximum value among neighbors (including self)
    val maxValue = neighborValues.max(base = localId)

    return maxValue
}

fun Aggregate<Int>.maxNetworkID(environment: EnvironmentVariables): Int {
    val maxLocalValue = maxNeighborID()

    // Step 3: Assign the result to a molecule
    environment["isMaxLocalID"] = localId == maxLocalValue
    environment["localID"] = localId
    environment["maxNeighborID"] = maxLocalValue

    // Step 1: Exchange the maxNeighborID with neighbors and obtain a field of values
    val neighborValues = neighboring(local = maxLocalValue)

    // Step 2: Find the maximum value among neighbors (including self)
    val maxValue = neighborValues.max(base = maxLocalValue)

    // Step 3: Assign the result to a molecule (only if using Alchemist)
    environment["isMaxID"] = localId == maxValue
    environment["maxNetworkID"] = maxValue
    
    return maxValue
}

```
<details style={{ backgroundColor: 'transparent', border: '1px solid purple', borderRadius: '5px', padding: '5px' }}>
  <summary>Click to view images</summary>
  <div style={{ textAlign: 'center' }}>
    <img src="/img/basic-usage-second-example-3.png" style={{ maxWidth: '70%' }} />
  </div>

  An additional layer of communication is introduced, as shown in the first image, which depicts the initial configuration where all nodes have the "isMaxID" flag set to true. In this second example, this flag represents the global maximum of the network. The flag previously used in the first example, called "isMaxID," has been renamed to "isMaxLocalID." A node for which "isMaxID == true" is represented in green, while a node for which "isMaxLocalID == true" is represented in red.
  
  Furthermore, in this example, the network is more interconnected. Taking this into account, along with the additional layer of communication between the nodes, where once a local maximum is identified, it will be communicated by all nodes within the interconnected subnet, these two characteristics will allow for the attainment of a global maximum.
  
  The resulting configuration after executing the code shown above is as follows:
  <div style={{ textAlign: 'center' }}>
    <img src="/img/basic-usage-second-example-2.png" style={{ maxWidth: '70%' }} />
  </div>

  There are four interconnected subnets, and the number of interconnected subnets is determined by the number of highlighted nodes. The nodes within each of these subnets communicate the local maximum value identified within them, thereby enabling the identification of the global maximum value of the entire network.
  <div style={{ textAlign: 'center' }}>
    <img src="/img/basic-usage-second-example-1.png" style={{ maxWidth: '70%' }} />
  </div>
  For the sake of visual clarity, the network is presented without the connection edges between the nodes. 
  
  Additionally, it should be noted that fewer nodes have been included compared to the previous example.
</details>

This second example represents a highly simplified demonstration of leader election using the Collektive library.

Specifically, in this first two examples, the use of aggregated operators and operations on the neighborhood field is analyzed.

## Third example

TODO

More examples can be found in the following repository: [Collektive Examples Repository](https://github.com/Collektive/collektive-examples).
