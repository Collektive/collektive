---
title: Basic Usage
---

# Simple examples

## First example

A preliminary code example demonstrates how devices, through mutual communication, are able to identify the maximum ID among the neighboring nodes within their local network area (neighborhood):

```kotlin
/**
 * First example - Tutorial:
 * 1. Identify the maximum value among the neighboring nodes.
 * 2. Assign a distinct color to the nodes with the identified maximum values.
*/

fun Aggregate<Int>.maxID(environment: EnvironmentVariables) = maxNeighborID(environment)

fun Aggregate<Int>.maxNeighborID(environment: EnvironmentVariables): Int {
    // Step 1: Exchange the localId with neighbors and obtain a field of values
    val neighborValues = neighboring(local = localId)

    // Step 2: Find the maximum value among neighbors (including self)
    val maxValue = neighborValues.max(base = localId)

    // Step 3: Assign the result to a molecule (only if using Alchemist)
    environment["isMaxID"] = localId == maxValue
    environment["localID"] = localId
    environment["maxNeighborID"] = maxValue

    return maxValue
}

```
The library function `neighboring(local: Scalar)` is a **aggregate operator** and is used to observe the value of an expression [local] across neighboring nodes.

#### Example

```kotlin
val field = neighboring(0)
```

The returned field has as its local value the value passed as input (0 in this example).

The simulation environment used to demonstrate these examples is [Alchemist simulator](https://alchemistsimulator.github.io/). 

However, it is important to emphasize that the Collektive library is designed for broader applicability and is not limited to this specific tool.

The correct execution of this exercise does not depend on Alchemist Simulator or the environment used for molecule assignment. The latter serves solely a graphical purpose, enabling the visualization of results by assigning different colors based on the identified maximum values.

<details style={{ backgroundColor: 'transparent', border: '1px solid purple', borderRadius: '5px', padding: '5px' }}>
  <summary>Click to view images</summary>
  <div style={{ textAlign: 'center' }}>
    <img src="/img/basic-usage-first-example-1.png" style={{ maxWidth: '70%' }} />
  </div>
  In the initial configuration depicted in the first image, all nodes have the "isMaxID" flag initially set to true. A node for which "isMaxID == true" is represented in red.

  It is observed that the network has a low degree of connectivity, leading to the formation of multiple small subnetworks. 
  
  The resulting configuration after executing the code shown above is as follows:
  <div style={{ textAlign: 'center' }}>
    <img src="/img/basic-usage-first-example-2.PNG" style={{ maxWidth: '70%' }} />
  </div>

  The obtained result is briefly analyzed by considering one of these small subnetworks as an example. Specifically, we examine the nodes with ID 197, 277, and the intermediate node connecting them. 
  <div style={{ textAlign: 'center' }}>
    <img src="/img/basic-usage-first-example-3.PNG" style={{ maxWidth: '70%' }} />
  </div>

  In the figure, the ID of the intermediate node between nodes 197 and 277 is not displayed, but it can reasonably be assumed to be lower than those of the other two nodes. For this reason, both node 277 and node 197 have the flag "isMaxID == true." However, it is observed that node 197 does not recognize node 277 as the maximum. This occurs because there is no direct communication between them, and each node only transmits its own ID to its neighbors. This mechanism leads to a solution characterized by local maxima.
</details>

The example we have seen represents a straightforward instance of aggregated behavior.

## Second example

This second example represents a variation of the previous one. Building upon the local maximum computation introduced in the first example, the code presented here extends the process through a second layer of communication among nodes, enabling convergence toward the global maximum of the network. 

**Note**: the global maximum is visually represented in green, while the local maximum is consistently indicated in red.

```kotlin
/**
 * First example - Tutorial:
 * 1. Identify the maximum value among the neighboring nodes.
 * 2. Assign a distinct color to the nodes with the identified maximum values.
 * Second example - Tutorial:
 * 3. Identify the maximum value in the network.
 * 4. Assign a distinct color to the nodes with the identified maximum values.
*/

fun Aggregate<Int>.maxID(environment: EnvironmentVariables) = maxNetworkID(environment)

fun Aggregate<Int>.maxNeighborID(): Int {
    // Step 1: Exchange the localId with neighbors and obtain a field of values
    val neighborValues = neighboring(local = localId)

    // Step 2: Find the maximum value among neighbors (including self)
    val maxValue = neighborValues.max(base = localId)

    return maxValue
}

fun Aggregate<Int>.maxNetworkID(environment: EnvironmentVariables): Int {
    val maxLocalValue = maxNeighborID()

    // Step 3: Assign the result to a molecule
    environment["isMaxLocalID"] = localId == maxLocalValue
    environment["localID"] = localId
    environment["maxNeighborID"] = maxLocalValue

    // Step 1: Exchange the maxNeighborID with neighbors and obtain a field of values
    val neighborValues = neighboring(local = maxLocalValue)

    // Step 2: Find the maximum value among neighbors (including self)
    val maxValue = neighborValues.max(base = maxLocalValue)

    // Step 3: Assign the result to a molecule (only if using Alchemist)
    environment["isMaxID"] = localId == maxValue
    environment["maxNetworkID"] = maxValue
    
    return maxValue
}

```
<details style={{ backgroundColor: 'transparent', border: '1px solid purple', borderRadius: '5px', padding: '5px' }}>
  <summary>Click to view images</summary>
  <div style={{ textAlign: 'center' }}>
    <img src="/img/basic-usage-second-example-3.png" style={{ maxWidth: '70%' }} />
  </div>

  An additional layer of communication is introduced, as shown in the first image, which depicts the initial configuration where all nodes have the "isMaxID" flag set to true. In this second example, this flag represents the global maximum of the network. The flag previously used in the first example, called "isMaxID," has been renamed to "isMaxLocalID." A node for which "isMaxID == true" is represented in green, while a node for which "isMaxLocalID == true" is represented in red.
  
  Furthermore, in this example, the network is more interconnected. Taking this into account, along with the additional layer of communication between the nodes, where once a local maximum is identified, it will be communicated by all nodes within the interconnected subnet, these two characteristics will allow for the attainment of a global maximum.
  
  The resulting configuration after executing the code shown above is as follows:
  <div style={{ textAlign: 'center' }}>
    <img src="/img/basic-usage-second-example-2.png" style={{ maxWidth: '70%' }} />
  </div>

  There are four interconnected subnets, and the number of interconnected subnets is determined by the number of highlighted nodes. The nodes within each of these subnets communicate the local maximum value identified within them, thereby enabling the identification of the global maximum value of the entire network.
  <div style={{ textAlign: 'center' }}>
    <img src="/img/basic-usage-second-example-1.png" style={{ maxWidth: '70%' }} />
  </div>
  For the sake of visual clarity, the network is presented without the connection edges between the nodes. 
  
  Additionally, it should be noted that fewer nodes have been included compared to the previous example.
</details>

This second example represents a highly simplified demonstration of leader election using the Collektive library.

Specifically, in this first two examples, the use of aggregated operators and operations on the neighborhood field is analyzed.

## Third example

In this final example, we extend the previous exercise with the goal of determining the diameter in relation to a source corresponding to the global maximum. To make the exercise more interesting, we reduce the number of nodes and the distance at which two nodes are connected, in order to obtain a larger number of diameter values. For each time step in the simulation, the average of these values will be calculated. 

Subsequently, we will analyze the behavior of the developed program using a graphical representation based on these data.

```kotlin
/**
 * Third example - Tutorial:
 * 1. Determine the diameter of the subnetworks corresponding to the nodes with the maximum global values of the last exercise.
 * 2. The nodes that are the farthest, in terms of hop count, from the maximum-value nodes (which serve as the center of the connected subnetwork) must be colored with different colors.
*/

// Preliminary step: define a data class to represent the association between a source node and its distance
data class SourceDistance(val sourceID: Int, val distance: Int)

fun Aggregate<Int>.diameter(sourceID: Int, distanceToSource: Int): SourceDistance {
    // Step 1: retrieve the distances from neighboring nodes, including the distance of the current node
    val distances = neighboring(SourceDistance(sourceID, distanceToSource))

    // Step 2: find the neighbor with the maximum distance for the given sourceID
    return distances.maxBy(SourceDistance(sourceID, distanceToSource)){ 

        // If the sourceID matches, return the actual distance; otherwise, Int.MIN_VALUE is used to exclude it
        if(sourceID == it.sourceID) it.distance else Int.MIN_VALUE 
    }
}

fun Aggregate<Int>.maxNetworkID(environment: EnvironmentVariables): Int {
    
    ...

    // Preliminary step: the distance from the nearest source is calculated using the hopDistanceTo library function 
    // (see the "Tutorial > Standard Library Functions" section for a detailed description)
    environment["distanceToSource"] = hopDistanceTo(environment["isMaxID"])

    val networkDiameter = diameter(environment["maxNetworkID"], environment["distanceToSource"])

    environment["diameter"] = networkDiameter

    val diameterDistance = networkDiameter.distance

    environment["diameterValue"] = diameterDistance
    environment["isDiameterDistance"] = diameterDistance == environment["distanceToSource"]
    environment["nothing"] =  !(environment["isDiameterDistance"] || environment["isMaxID"] || environment["isMaxLocalID"])

    return maxValue
}
```

<details style={{ backgroundColor: 'transparent', border: '1px solid purple', borderRadius: '5px', padding: '5px' }}>
  <summary>Click to view images</summary>

  The colors used to represent the local and global maxima of the network are the same as those described in the previous exercise. An additional color (violet) has been introduced to highlight the nodes that are furthest from their nearest source among the nodes within the network of that particular source.
  <div style={{ textAlign: 'center' }}>
    <img src="/img/basic-usage-third-example-1.PNG" style={{ maxWidth: '70%' }} />
  </div>

  For the sake of clarity in visualization, the network is presented without the connecting links between the nodes.
  
  **Note**: the label value of a node represents the value of the source id identified by that node.
  <div style={{ textAlign: 'center' }}>
    <img src="/img/basic-usage-third-example-2.PNG" style={{ maxWidth: '70%' }} />
  </div>

  Finally, the graph representing the average diameter resulting from the simulation is presented. The analysis of the graph shows that, once the communication between nodes stabilizes, the average diameter converges to a value of 2.
  <div style={{ textAlign: 'center' }}>
    <img src="/img/basic-usage-third-example-3.png" style={{ maxWidth: '70%' }} />
  </div>
</details>

More examples can be found in the following repository: [Collektive Examples Repository](https://github.com/Collektive/collektive-examples).
