---
title: Aggregate Operators and Field Operations
---

import { useState } from "react";
import ReactMarkdown from "react-markdown";
import rehypeRaw from 'rehype-raw';

export default function OperatorList() {
const operators = [
{ name: ` sharing(initial: Initial, noinline transform: YieldingContext<Initial, Return>.(Field<ID, Initial>) -> YieldingResult<Initial, Return>): 

Return = exchanging(initial) { field: Field<ID, Initial> ->
>with(YieldingContext<Initial, Return>()) {
>>val result: YieldingResult<Initial, Return> = transform(field)
>>field.map { result.toSend }.yielding {
>>>field.map { result.toReturn }

>>}

>}

}.localValue

`, description: ` \## Description 
\`sharing(initial: Initial, noinline transform: YieldingContext<Initial, Return>.(Field<ID, Initial>) -> YieldingResult<Initial, Return>)\` is an aggregate operator: captures the space-time nature of field computation through observation of neighbors' values, 
starting from an \`initial\` value, it reduces to a single local value given a \`transform\` function and updating and sharing to neighbors of a local variable.

\### Example

\`\`\`kotlin
val result = sharing(0) {
val maxValue = it.maxBy { v -> v.value }.value
    maxValue.yielding { "Something different" }
}
result // result: kotlin.String
\`\`\`

In the example above, the function \`sharing\` will return the string initialized as in yielding.

\#### Invalid use: 

Do not write code after calling the sending or returning values, they must be the last statement of the body (the lambda expression).

\`\`\`kotlin
share(0) {
    val maxValue = it.maxBy { v -> v.value }.value
    maxValue.yielding { "Don't do this" }
    maxValue
}
\`\`\`

`},
{ name:`share(initial: Initial, noinline transform: (Field<ID, Initial>) -> Initial): 
    
Initial = sharing(initial) { field -> transform(field).run { yielding { this } } }
`, description: ` \## Description 

\` share(initial: Initial, noinline transform: (Field<ID, Initial>) -> Initial) \` is an aggregate operator: captures the space-time nature of field computation through observation of neighbours' values, starting from an \`initial\` value, it reduces to a single local value given a \`transform\` function and updating and sharing to neighbours of a local variable.
 
\### Example

\`\`\`kotlin
val result = share(0) {
    it.maxBy { v -> v.value }.value
}
result // result: kotlin.Int
\`\`\`

In the example above, the function \`share\` wil return a value that is the max found in the field.`
},
{ name:`neighboringViaExchange(local: Scalar): 

Field<ID, Scalar> = exchanging(local) { toYield -> toYield.mapToConstantField(local).yielding { toYield } }
`, 
description: ` \## Description 

\`neighboringViaExchange(local: Scalar)\` is an aggregate operator: observes the value of an expression \`local\` across neighbours.

\### Example 

\`\`\`kotlin
val field = neighboring(0)
\`\`\`

The field returned has as local value the value passed as input (0 in this example).

\`\`\`kotlin
val field = neighboring({ 2 * 2 })
\`\`\`

In this case, the field returned has the result of the computation as local value.
` 
},
{ name:`all(base: Boolean, predicate: (Boolean) -> Boolean = { it }): 

Boolean = fold(predicate(base)) { acc, value -> acc && predicate(value) }
`, description:`\## Description 

\`all(base: Boolean, predicate: (Boolean) -> Boolean = { it })\` is a boolean field operation: check if all the \`Boolean\` elements in the field are true by default.

If \`predicate\` is defined, it is applied to the elements.

The \`base\` value is used as a first element to start the fold operation at which the \`predicate\` is applied.
` 
},
{ name:`all(crossinline predicate: (T) -> Boolean):

Boolean = fold(true) { acc, value -> acc && predicate(value) }
`, description: `\## Description 

\`all(crossinline predicate: (T) -> Boolean)\` is a field operation: check if all the elements in the field satisfy the \`predicate\`, ignoring the local value.
`
},
{ name:`allWithSelf(crossinline predicate: (T) -> Boolean): 

Boolean = all(predicate) && predicate(localValue)
`, description: `\## Description 

\`allWithSelf(crossinline predicate: (T) -> Boolean)\` is a field operation: check if all the elements in the field satisfy the \`predicate\`, including the local value.` },
{ name:`any(base: Boolean, predicate: (Boolean) -> Boolean = { it }): 

Boolean = fold(predicate(base)) { acc, value -> acc || predicate(value) }
`, description: `\## Description 

\`any(base: Boolean, predicate: (Boolean) -> Boolean = { it })\` is a boolean field operation: check if any of the \`Boolean\` elements in the field are true by default.

If \`predicate\` is defined, it is applied to the elements.

The \`base\` value is used as a first element to start the fold operation at which the \`predicate\` is applied.` },
{ name:`any(crossinline predicate: (T) -> Boolean): 

Boolean = fold(false) { acc, value -> acc || predicate(value) }
`, description: `\## Description 

\`any(crossinline predicate: (T) -> Boolean)\` is a field operation: check if any of the elements in the field satisfy the \`predicate\`, ignoring the local value.` },
{ name:`anyWithSelf(crossinline predicate: (T) -> Boolean): 

Boolean = any(predicate) || predicate(localValue)
`, description: `\## Description 

\`anyWithSelf(crossinline predicate: (T) -> Boolean)\` is a field operation: check if any of the elements in the field satisfy the \`predicate\`, including the local value.` },
{ name:`none(base: Boolean, predicate: (Boolean) -> Boolean = { it }): 

Boolean = !all(base, predicate)
`, description: `\## Description 

\`none(base: Boolean, predicate: (Boolean) -> Boolean = { it })\` is a boolean field operation: check if none of the \`Boolean\` elements in the field are true by default.

If \`predicate\` is defined, it is applied to the elements.

The \`base\` value is used as a first element to start the fold operation at which the \`predicate\` is applied.
` },
{ name:`none(crossinline predicate: (T) -> Boolean): 

Boolean = !any(predicate)`, description: `\## Description

\`none(crossinline predicate: (T) -> Boolean)\` is a field operation: check if none of the elements in the field satisfy the \`predicate\`, ignoring the local value.

 ` },
{ name:`noneWithSelf(crossinline predicate: (T) -> Boolean): 

Boolean = !anyWithSelf(predicate)`, description: `\## Description 

\`noneWithSelf(crossinline predicate: (T) -> Boolean)\` is a field operation: check if none of the elements in the field satisfy the \`predicate\`, including the local value.
` },
{ name:`min(base: T): 

T = fold(base) { acc, value -> if (value < acc) value else acc }
`, description: `\## Description 

\` min(base: T) \` is a comparable field operation: get the minimum value of a field, excluding the local value, starting from \`base\`.

To consider the local value, explicitly provide it as \`base\`.
` },
{ name:`minWithSelf():

T = min(localValue)
`, description: `\## Description 
\`minWithSelf()\` is a comparable field operation: get the minimum value of a field, including the local value.
` },
{ name:`minWith`, description: `\## Description ` },
{ name:`minBy`, description: `\## Description ` },
{ name:`max(base: T): 

T = fold(base) { acc, value -> if (value > acc) value else acc }
`, description: `\## Description 

\`max(base: T)\` is a comparable field operation: get the maximum value of a field, excluding the local value, starting from \`base\`.

To consider the local value, explicitly provide it as \`base\`.
` },
{ name:`maxWithSelf(): T = max(localValue)`, description: `\## Description 

\`maxWithSelf()\` is a comparable field operation: get the maximum value of a field, including the local value.
` },
{ name:`maxWith`, description: `\## Description ` },
{ name:`maxBy`, description: `\## Description ` },
{ name:`count(crossinline predicate: (T) -> Boolean = { true }): 

Int = fold(0) { acc, value -> if (predicate(value)) acc + 1 else acc }
`, description: `\## Description 

\`count(crossinline predicate: (T) -> Boolean = { true })\` is a field operation: count the number of elements in the field that satisfy the \`predicate\`, ignoring the local value.
` },
{ name:`countWithSelf(crossinline predicate: (T) -> Boolean = { true }): 

Int = count(predicate) + if (predicate(localValue)) 1 else 0
`, description: `\## Description 

\`countWithSelf(crossinline predicate: (T) -> Boolean = { true })\` is a field operation: count the number of elements in the field that satisfy the \`predicate\`, including the local value.

` },
{ name:`replaceMatchingWithId`, description: `\## Description ` },
{ name:`replaceMatching`, description: `\## Description ` },
{ name:`excludeSelf`, description: `\## Description ` },
{ name:`alignedMapWithId`, description: `\## Description ` },
{ name:`alignedMap`, description: `\## Description ` },
{ name:`mapWithId`, description: `\## Description ` },
{ name:`map`, description: `\## Description ` },
{ name:`mapToConstantField`, description: `\## Description ` },
{ name:`get`, description: `\## Description ` },
{ name:`asSequence`, description: `\## Description ` },
{ name:`toMap`, description: `\## Description ` },
{ name:`exchange`, description: `\## Description ` },
{ name:`exchanging`, description: `\## Description ` },
{ name:`evolve`, description: `\## Description ` },
{ name:`evolving`, description: `\## Description ` },
{ name:`neighboring`, description: `\## Description ` },
{ name:`alignedOn`, description: `\## Description ` },
{ name:`align`, description: `\## Description ` },
{ name:`dealign`, description: `\## Description ` },
];

const [search, setSearch] = useState("");

// Filter operators based on search
const filteredOperators = operators.filter(op =>
    op.name.toLowerCase().includes(search.toLowerCase())
);

const highlightMatch = (text, searchTerm) => {
    if (!searchTerm) return text; 
    const escapedSearchTerm = searchTerm.replace(/[-/\\^$*+?.()|[\]{}]/g, '\\$&');

    const regex = new RegExp(`(${escapedSearchTerm})`, 'gi');
    return text.replace(regex, (match) => {
        return `<mark class="bg-yellow-300">${match}</mark>`; 
    });
};

return (
    <div className="max-w-md mx-auto p-6 bg-white shadow-lg rounded-2xl">
        <h2 className="text-xl font-semibold text-purple-600 mb-4">
        The operators present in the Collektive library are illustrated below
        </h2>
        
        {/* Search bar */}
        <input
        type="text"
        placeholder="ðŸ” Search for a function..."
        className="w-full h-12 p-3 text-lg border rounded-lg focus:outline-none focus:ring-2 focus:ring-purple-400"
        value={search}
        onChange={(e) => setSearch(e.target.value)}
        />

        {/* Operator list with description in Markdown */}
        <ul className="mt-4 space-y-3">
        {filteredOperators.length > 0 ? (
            filteredOperators.map((op) => (
            <li key={op.name} className="p-3 bg-gray-100 rounded-lg shadow-sm text-lg">
                <ReactMarkdown 
                    className="font-bold text-purple-700"
                    children={highlightMatch(op.name, search)} 
                    rehypePlugins={[rehypeRaw]}
                />
                <details style={{ backgroundColor: 'transparent', border: '1px solid purple', borderRadius: '5px', padding: '5px' }}>
                    <summary>Click to view description</summary>
                    <ReactMarkdown className="text-gray-600 text-sm">
                            {op.description}
                    </ReactMarkdown>
                </details>
            </li>
            ))
        ) : (
            <li className="text-gray-500 text-lg">No operators found</li>
        )}
        </ul>
    </div>
);
}
