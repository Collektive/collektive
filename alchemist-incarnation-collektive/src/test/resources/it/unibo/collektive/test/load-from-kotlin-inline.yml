network-model:
  type: ConnectWithinDistance
  parameters: [5]

incarnation: collektive

_pool: &program
  - time-distribution: 1
    program: |
      package my.test
      
      import it.unibo.collektive.aggregate.api.Aggregate
      import it.unibo.collektive.aggregate.api.operators.share
      import it.unibo.collektive.alchemist.device.DistanceSensor
      import it.unibo.collektive.field.*
      import kotlin.Double.Companion.POSITIVE_INFINITY
      
      context(DistanceSensor)
      fun Aggregate<Int>.gradient(source: Boolean): Double =
        share(POSITIVE_INFINITY) {
          val dist = distances()
          when {
            source -> 0.0
            else -> (it + dist).min(POSITIVE_INFINITY)
          }
        }
      
      collektive { gradient(localId == 0) }

deployments:
  - type: Rectangle
    parameters: [200, 0, 0, 20, 20]
    programs:
      - *program
    contents:
      - molecule: source
        concentration: false
  - type: Point
    parameters: [2, 2]
    programs:
      - *program
    contents:
      - molecule: source
        concentration: true
